# -*- coding: utf-8 -*-
import pygame
import sys

from objects.draw_walls import rect_1

z = int(14)
# z равна половине ширины коридора между стенами
# Размер Pacman и привидений = 2 * z
# size = width, height = определяется как размер загруженного поля
# Размеры поля могут быть изменяемы в зависимости от того какое поле загружено (размеры матрицы поля -1)
black = 0, 0, 0
green = 0, 255, 0
blue = 0, 0, 255
red = 255, 0, 0
yellow = 255, 255, 153

# 2 - Поле для очков и другой информации
# 0 , 3 - Ячейки по которым могут ходить "Герои"
# 3 - Ячейки, в которых возможны повороты
# 1 - Ячейки, на которых расположены "Стены"
# Реализован промежуточный вариант отображения поля, цветом выделены пути, по которым могут ходить
# Центр фигур должен ходить по центру показанных дорожек
# Правильное отображение поле будет позднее
# матрицу pole_xy можно использовать для размещения фигур на поле
# Если pole_xy[i][j] == 0, то в эту ячейку можно поместить зерно , Pacman , Привидений.
# Координата центра ячейки (j * z + z// 2; i * z + z // 2) ---!!! НЕ ВЕРНО - центр 4 точки
# Координаты для размещения фигур:
# Если помещаем фигуру и ее центр должен совпадать с центром клеточки,
# ее координаты должна быть:
# если круг, то центр круга - ((j * z  + z // 2; i * z + z // 2)
# Если фигура прямоугольник, (x , y - ширина, высота )
# то координаты ее левого верхнего угла должны быть
# Координаты:  (j * z  + (z-x)// 2; i * z + (z-y) // 2)

pole_xy = [[2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2],
           [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2],
           [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2],
           [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
           [1, 3, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 3, 1, 1, 3, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 3, 1],
           [1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1],
           [1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1],
           [1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1],
           [1, 3, 0, 0, 0, 0, 3, 0, 0, 3, 0, 0, 3, 0, 0, 3, 0, 0, 3, 0, 0, 3, 0, 0, 0, 0, 3, 1],
           [1, 0, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1],
           [1, 0, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1],
           [1, 3, 0, 0, 0, 0, 3, 1, 1, 3, 0, 0, 3, 1, 1, 3, 0, 0, 3, 1, 1, 3, 0, 0, 0, 0, 3, 1],
           [1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1],
           [1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1],
           [1, 1, 1, 1, 1, 1, 0, 1, 1, 3, 0, 0, 3, 0, 0, 3, 0, 0, 3, 1, 1, 0, 1, 1, 1, 1, 1, 1],
           [1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1],
           [1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1],
           [0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0],
           [1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1],
           [1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1],
           [1, 1, 1, 1, 1, 1, 0, 1, 1, 3, 0, 0, 0, 0, 0, 0, 0, 0, 3, 1, 1, 0, 1, 1, 1, 1, 1, 1],
           [1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1],
           [1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1],
           [1, 3, 0, 0, 0, 0, 3, 0, 0, 3, 0, 0, 3, 1, 1, 3, 0, 0, 3, 0, 0, 3, 0, 0, 0, 0, 3, 1],
           [1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1],
           [1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1],
           [1, 3, 0, 3, 1, 1, 3, 0, 0, 3, 0, 0, 3, 0, 0, 3, 0, 0, 3, 0, 0, 3, 1, 1, 3, 0, 3, 1],
           [1, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 1],
           [1, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 1],
           [1, 3, 0, 3, 0, 0, 3, 1, 1, 3, 0, 0, 3, 1, 1, 3, 0, 0, 3, 1, 1, 3, 0, 0, 3, 0, 3, 1],
           [1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1],
           [1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1],
           [1, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 1],
           [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
           [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2],
           [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]
           ]

size = width, height = z * len(pole_xy[0]), z * len(pole_xy)


def show_field(screen, field=pole_xy, color_f=(0, 0, 255)):
    """
    Функция отрисовки поля
    """
    for yy in range((len(pole_xy))):
        for xx in range(len(pole_xy[yy])):
            if int(pole_xy[yy][xx]) == 0:
                pygame.draw.rect(screen, color_f, (z * xx, z * yy, z, z), 0)
            elif int(pole_xy[yy][xx]) == 3:
                pygame.draw.rect(screen, color_f, (z * xx, z * yy, z, z), 0)
            else:
                pass
    rect_1(screen, 2 * z + z // 2, 5 * z + z // 2, 3 * z, 2 * z, 3, 3)
    rect_1(screen, 7 * z + z // 2, 5 * z + z // 2, 4 * z, 2 * z, 3, 3)
    rect_1(screen, 16 * z + z // 2, 5 * z + z // 2, 4 * z, 2 * z, 3, 3)
    rect_1(screen, 22 * z + z // 2, 5 * z + z // 2, 3 * z, 2 * z, 3, 3)
    rect_1(screen, 2 * z + z // 2, 9 * z + z // 2, 3 * z - 2, 1 * z - 2, 3, 3)
    rect_1(screen, 22 * z + z // 2, 9 * z + z // 2, 3 * z - 2, 1 * z - 2, 3, 3)
    rect_1(screen, 7 * z + z // 2, 18 * z + z // 2, 1 * z - 2, 4 * z - 2, 3, 3)
    rect_1(screen, 19 * z + z // 2, 18 * z + z // 2, 1 * z - 2, 4 * z - 2, 3, 3)
    rect_1(screen, 7 * z + z // 2, 24 * z + z // 2, 4 * z - 2, 1 * z - 2, 3, 3)
    rect_1(screen, 16 * z + z // 2, 24 * z + z // 2, 4 * z - 2, 1 * z - 2, 3, 3)


def field():
    """
    демо отрисовка поля
    """
    pygame.init()
    screen = pygame.display.set_mode(size)
    gameover = False

    while not gameover:
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                gameover = True
        screen.fill(black)
        show_field(screen, pole_xy, (0, 0, 127))
        #fig_6(screen, 20, 130, 300, 200, 50, 5, 1)
        #rect_1(screen, 2*z+z//2, 9*z+z//2, 3*z-5, 2*z-5 ,3, 5 )
        #rect_1(screen, 2*z+z//2, 11*z+z//2, 3*z-20, 2*z-20 ,3, 10 )
        pygame.display.flip()
        pygame.time.wait(10)
    sys.exit()


def get_pos_in_field(x,y):
    """
    Функция возвращает кортеж избавиться индексов 
    клетки в которой находиться точка(зависит отображение z)

    """
    xx, yy = 0,0    
    if x % z != 0:
        xx = x // z              # индекс с 0
    else:
        xx = x // z - 1
    if y % z != 0:
        yy = y // z              # индекс с 0
    else:
        yy = y // z - 1
    return xx,yy


def is_cell_centre(x,y):
    """
    Логическая функция возвращает True если точка находиться 
    в центре пиксельной клетки(зависит от z)

    is_cell_centre(7,8) -> True
    """
    flag = False
    if z % 2 == 0:
        if(abs(x%z - z/2) <= 1) and (abs(y%z - z/2) <= 1):
            flag = True
    else:
        if(x%z == (z//2+1)) and (y%z == (z//2+1)):
            flag = True
    return flag


if __name__ == '__main__':
    field()
