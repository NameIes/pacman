# -*- coding: utf-8 -*-
import pygame
import sys


class Grain:
    grainArray = []

    def __init__(self, center_x, center_y, radius=2, color=(255, 255, 0)):
        self.center_x = center_x
        self.center_y = center_y
        self.radius = radius
        self.color = color

    def draw(self, screen):
        pygame.draw.circle(screen, self.color, (self.center_x, self.center_y), self.radius)

    def append(self):
        for count in range(0, 239):
            self.center_x = count
            self.center_y = count
            self.grainArray.append(Grain((self.center_x, self.center_y), self.radius, self.color))


# class Energizer(Grain):

#    def __init__(self, center_x, center_y, radius = 2, color = (255, 255, 0)):
#        super().__init__(center_x, center_y)
#        self.radius = 7

#    def draw(self, screen):
#        pygame.draw.circle(screen, self.color,(self.center_x, self.center_y), self.radius)


z = int(14)
# z равна половине ширины коридора между стенами
# Размер Pacman и привидений = 2 * z
# size = width, height = определяется как размер загруженного поля
# Размеры поля могут быть изменяемы в зависимости от того какое поле загружено (размеры матрицы поля -1)
black = 0, 0, 0
green = 0, 255, 0
blue = 0, 0, 255
red = 255, 0, 0
yellow = 255, 255, 153

# 2 - Поле для очков и другой информации
# 0 , 3 - Ячейки по которым могут ходить "Герои"
# 3 - Ячейки, в которых возможны повороты
# 1 - Ячейки, на которых расположены "Стены"
# Реализован промежуточный вариант отображения поля, цветом выделены пути, по которым могут ходить
# Центр фигур должен ходить по центру показанных дорожек
# Правильное отображение поле будет позднее
# матрицу pole_xy можно использовать для размещения фигур на поле
# Если pole_xy[i][j] == 0, то в эту ячейку можно поместить зерно , Pacman , Привидений.
# Координата центра ячейки (j * z + z// 2; i * z + z // 2) ---!!! НЕ ВЕРНО - центр 4 точки
# Координаты для размещения фигур:
# Если помещаем фигуру и ее центр должен совпадать с центром клеточки,
# ее координаты должна быть:
# если круг, то центр круга - ((j * z  + z // 2; i * z + z // 2)
# Если фигура прямоугольник, (x , y - ширина, высота )
# то координаты ее левого верхнего угла должны быть
# Координаты:  (j * z  + (z-x)// 2; i * z + (z-y) // 2)


pole_xy = [[2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2],
           [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2],
           [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2],
           [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
           [1, 3, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 3, 1, 1, 3, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 3, 1],
           [1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1],
           [1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1],
           [1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1],
           [1, 3, 0, 0, 0, 0, 3, 0, 0, 3, 0, 0, 3, 0, 0, 3, 0, 0, 3, 0, 0, 3, 0, 0, 0, 0, 3, 1],
           [1, 0, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1],
           [1, 0, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1],
           [1, 3, 0, 0, 0, 0, 3, 1, 1, 3, 0, 0, 3, 1, 1, 3, 0, 0, 3, 1, 1, 3, 0, 0, 0, 0, 3, 1],
           [1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1],
           [1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1],
           [1, 1, 1, 1, 1, 1, 0, 1, 1, 3, 0, 0, 3, 0, 0, 3, 0, 0, 3, 1, 1, 0, 1, 1, 1, 1, 1, 1],
           [1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1],
           [1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1],
           [0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0],
           [1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1],
           [1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1],
           [1, 1, 1, 1, 1, 1, 0, 1, 1, 3, 0, 0, 0, 0, 0, 0, 0, 0, 3, 1, 1, 0, 1, 1, 1, 1, 1, 1],
           [1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1],
           [1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1],
           [1, 3, 0, 0, 0, 0, 3, 0, 0, 3, 0, 0, 3, 1, 1, 3, 0, 0, 3, 0, 0, 3, 0, 0, 0, 0, 3, 1],
           [1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1],
           [1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1],
           [1, 3, 0, 3, 1, 1, 3, 0, 0, 3, 0, 0, 3, 0, 0, 3, 0, 0, 3, 0, 0, 3, 1, 1, 3, 0, 3, 1],
           [1, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 1],
           [1, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 1],
           [1, 3, 0, 3, 0, 0, 3, 1, 1, 3, 0, 0, 3, 1, 1, 3, 0, 0, 3, 1, 1, 3, 0, 0, 3, 0, 3, 1],
           [1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1],
           [1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1],
           [1, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 1],
           [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
           [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2],
           [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]
           ]

SIZE = width, height = z * len(pole_xy[0]), z * len(pole_xy)


def show_field(screen, field=pole_xy, color_f=(0, 0, 255)):
    for yy in range((len(pole_xy))):
        for xx in range(len(pole_xy[yy])):
            if int(pole_xy[yy][xx]) == 1:
                pygame.draw.rect(screen, color_f, (z * xx, z * yy, z, z), 0)
            # elif int(pole_xy[yy][xx]) == 3:
            # pygame.draw.rect(screen, color_f, (z * xx, z * yy, z, z), 0)
            else:
                pass


def get_pos_in_field(x, y):
    xx, yy = 0, 0
    if x % z != 0:
        xx = x // z
    else:
        xx = x // z - 1
    if y % z != 0:
        yy = y // z
    else:
        yy = y // z - 1
    return xx, yy


def is_cell_centre(x, y):
    flag = False
    if z % 2 == 0:
        if ((x % z - z / 2) <= 1) and ((y % z - z / 2) <= 1):
            flag = True
    else:
        if (x % z == (z // 2 + 1)) and (y % z == (z // 2 + 1)):
            flag = True
    return flag


# Функция постановки зёрен на поле и проверка на их присутствие/отстутствие на поле
def import_grain(x, y, xx, yy, grainArray):
    get_pos_in_field(x, y)
    count = 0
    for i in range(35):
        j = 0
        for j in range(27):
            if pole_xy[yy][xx] == 0:
                pole_xy[yy][xx] = grainArray[count]
            if pole_xy[yy][xx] == grainArray[count]:
                print "True"
            else:
                print "False"
            count += 1


def main():
    size = (800, 600)
    black = (0, 0, 0)

    pygame.init()
    screen = pygame.display.set_mode(size)

    g1 = Grain(100, 100)
    # g2 = Energizer(50, 50)

    game_over = False
    while not game_over:
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                game_over = True

        screen.fill(black)

        g1.draw(screen)

        pygame.display.flip()
        pygame.time.wait(10)

    sys.exit(0)


if __name__ == '__main__':
    main()
